return(total_distance)
} else {
return(0)  # Return 0 if there's only one or zero points
}
})
# Convert the list of distances into a data frame
traveled_distances_df <- do.call(rbind, lapply(names(traveled_distances), function(code_dista) {
data.frame(Code = code_dista, Distance_km = traveled_distances[[code_dista]], row.names = NULL)
}))
# Remove the "[m]" suffix from the "Distance_km" column
traveled_distances_df$Distance_km <- gsub("\\s*\\[m\\]", "", traveled_distances_df$Distance_km)
# ##################### Merge the homerange and distance columns #############################################
merged_distance_homerange <- merge(traveled_distances_df, home2, by="Code")
# Splitting the Code column into three separate columns
merged_distance_homerange_split <- tidyr::separate(merged_distance_homerange, Code, into = c("Month", "Year", "Id"), sep = " ")
# Change the name of area
names(merged_distance_homerange_split) <- c("Month", "Year", "Id", "Distance_km", "Area_km2")
# Final file ready for correlation analysis
final_file <- merged_distance_homerange_split
return(final_file)
}
#' Correlation between the area utilized and traveled distance
#'
#' @param adista a layer containing the area and distances values generated from the homdista function
#' @param cormethod correlation method between paired samples (pearson", "kendall", or "spearman")
#'
#' @return correlation_dist_homer
#' @export
#'
#' @examples hodicor
hodicor <- function(adista, cormethod){
# Re-read the file name returned from homdista
final_file <- adista
# Correlation
correlation_dist_homer <- cor.test(as.numeric(final_file$Distance_km), as.numeric(final_file$Area_km2), method = cormethod,
conf.level = 0.95)
# Create a scatter plot with a fitted line
# Convert Month and Year columns to factors
final_file$Month <- factor(final_file$Month)
final_file$Year <- factor(final_file$Year)
# Create the scatter plot
corplot <- qplot(x = Distance_km, y = Area_km2, col= Id, data = final_file) +
geom_smooth(method = "lm") + xlab("Distance [km]") +
ylab("Area [km2]") + xlim(min(final_file$Distance_km), max(final_file$Distance_km)) +
ylim(min(final_file$Area_km2), max(final_file$Area_km2)) + guides(col = guide_legend(title = NULL))
plot(corplot)
return(correlation_dist_homer)
}
final_file <- adista
library(homdista)
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
# Compute the area utilized and distance traveled by elephant
area_distance <- homdista::homdista(file, tf, Id_name, crs_epsg, perc)
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
# Compute the area utilized and distance traveled by elephant
area_distance <- homdista::homdista(file, tf, Id_name, crs_epsg, perc)
# Compute the area utilized and distance traveled by elephant
area_distance <- homdista::homdista(file, tf, crs_epsg, Id_name, perc)
area_distance
# Home range spatial polygons
homerange_polygons <- homdista::homekde(file, tf, crs_epsg, Id_name, perc)
# Check the correlation between area used and traveled distance
corr_home_distance <- homdista::hodicor(area_distance, "spearman")
# Spatial lines (paths) showing traveled distance
distance_paths <- homdista::distwalk(file, tf, crs_epsg, Id_name)
mapview(distance_paths)
library(homdista)
library(homdista)
devtools::install_github("https://github.com/2023Jado/homdista")
devtools::install_github("https://github.com/2023Jado/homdista")
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
# Compute the area utilized and distance traveled by elephant with "homdista"
area_distance <- homdista::homdista(file, tf, crs_epsg, Id_name, perc)
# Compute the area utilized and distance traveled by elephant with "homdista"
area_distance <- homdista::homdista(file, tf, crs_epsg, Id_name, perc)
# Home range spatial polygons "homkde"
homerange_polygons <- homdista::homekde(file, tf, crs_epsg, Id_name, perc)
# Check the correlation between area used and traveled distance using "spearman method"
corr_home_distance <- homdista::hodicor(area_distance, "spearman")
# Spatial lines (paths) showing traveled distance
distance_paths <- homdista::distwalk(file, tf, crs_epsg, Id_name)
mapview(distance_paths)
homerange_polygons
corr_home_distance
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
# Compute the area utilized and distance traveled by elephant with "homdista"
area_distance <- homdista::homdista(file, tf, crs_epsg, Id_name, perc)
# Home range spatial polygons "homkde"
homerange_polygons <- homdista::homekde(file, tf, crs_epsg, Id_name, perc)
# Check the correlation between area used and traveled distance using "spearman method"
corr_home_distance <- homdista::hodicor(area_distance, "spearman")
# Spatial lines (paths) showing traveled distance
distance_paths <- homdista::distwalk(file, tf, crs_epsg, Id_name)
mapview(distance_paths)
library(homdista)
roxygen2::roxygenize()
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
libary(homdista)
libary(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
roxygen2::roxygenize()
devtools::document()
devtools::document()
library(homdista)
devtools::document()
library(homdista)
library(homdista)
devtools::document()
library(homdista)
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
# Compute the area utilized and distance traveled by elephant with "homdista"
area_distance <- homdista::homdista(file, tf, crs_epsg, Id_name, perc)
# Check the correlation between area used and traveled distance using "spearman method"
corr_home_distance <- homdista::hodicor(area_distance, "spearman")
# Spatial lines (paths) showing traveled distance
distance_paths <- homdista::distwalk(file, tf, crs_epsg, Id_name)
mapview(distance_paths)
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
# Compute the area utilized and distance traveled by elephant with "homdista"
area_distance <- homdista::homdista(file, tf, crs_epsg, Id_name, perc)
devtools::document()
roxygen2::roxygenize()
rlang::last_trace()
devtools::document()
library(homdista)
devtools::document()
library(homdista)
file <- read.csv("C:/Users/Jado/Documents/EAGLE/Semester 2/Data/African elephant Jammes Hwange NP2.csv", header=T)
tf <- "%m/%d/%y %H:%M"
Id_name <- "Animal"
crs_epsg <- 32734
perc <- 95
library(homdista)
library(terra)
terra::
terra::
terra::
library(homdista)
library(homdista)
devtools::document()
library(homdista)
devtools::document()
library(homdista)
roxygen2::roxygenize()
roxygen2::roxygenize()
library(homdista)
devtools::document()
library(homdista)
library(homdista)
roxygen2::roxygenize()
devtools::document()
library(homdista)
roxygen2::roxygenize()
devtools::document()
data_df <- file
data_df
data_df
# Create a data frame with codes and corresponding lines
lines_df <- data.frame(Code = rep(codes, sapply(lines_list, length)),
geometry = do.call("c", lines_list),
row.names = NULL)
# Convert the list of distances into a data frame
traveled_distances_df <- do.call(rbind, lapply(names(traveled_distances), function(code_dista) {
data.frame(Code = code_dista, Distance_km = traveled_distances[[code_dista]], row.names = NULL)
}))
file <- read.csv("C:/Users/Jado/Documents/DFGF/RE_HR_analysis_2020-2022/Combined file RDB & KRC/test_test.csv")
data_df <- file
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = "%m/%d/%y %I:%M %p", tz="UTC")
# Rename the column
names(data_df)[which(names(data_df) == "GORILLA_GROUP")] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = "%m/%d/%y %I:%M %p", tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
# Sort the dataset based on the timestamp column
no_na_df_sorted <- data_df_no_na[order(data_df_no_na$time), ]
no_na_data_unique <- data_df_no_na
# Create a "code name" column to be used for home range estimation
no_na_data_unique$Month_code <- month(no_na_data_unique$time)
library(sp)
library(sf)
library(ade4)
library(adehabitatMA)
library(CircStats)
library(adehabitatLT)
library(adehabitatHR)
library(move)
library(lubridate)
library(amt)
library(ggplot2)
library(scales)
library(mapview)
library(circular)
library(basemaps)
library(raster)
library(tidyr)
file <- read.csv("C:/Users/Jado/Documents/DFGF/RE_HR_analysis_2020-2022/Combined file RDB & KRC/test_test.csv")
data_df <- file
# Rename the column
names(data_df)[which(names(data_df) == "GORILLA_GROUP")] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = "%m/%d/%y %I:%M %p", tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
no_na_data_unique <- data_df_no_na
# Create a "code name" column to be used for home range estimation
no_na_data_unique$Month_code <- month(no_na_data_unique$time)
no_na_data_unique$Year_code <- year(no_na_data_unique$time)
no_na_data_unique$Code <- paste(no_na_data_unique$Month_code, no_na_data_unique$Year_code, no_na_data_unique$groupid)
no_na_data_unique$Month_code
no_na_data_unique$Year_code
no_na_data_unique$Code
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Iterate over each unique name in the "Code" column
unique_names <- unique(df_move$Code)
df_move <- no_na_data_unique
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Iterate over each unique name in the "Code" column
unique_names <- unique(df_move$Code)
unique_names
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Calculate KDE only if there are at least 5 relocations
if (num_relocations >= 5) {
kde <- kernelUD(as(subset_data, "SpatialPoints"), h = 200)
kde_list[[name]] <- kde
} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
df_move <- st_as_sf(no_na_data_unique, coords = c("x", "y"), crs=32735)
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Iterate over each unique name in the "Code" column
unique_names <- unique(df_move$Code)
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Calculate KDE only if there are at least 5 relocations
if (num_relocations >= 5) {
kde <- kernelUD(as(subset_data, "SpatialPoints"), h = 200)
kde_list[[name]] <- kde
} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
df_move
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Calculate KDE only if there are at least 5 relocations
if (num_relocations >= 5) {
kde <- kernelUD(as(subset_data, "SpatialPoints"), h = 200)
kde_list[[name]] <- kde
} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
# Loop through each unique name
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Calculate KDE only if there are at least 5 relocations
if (num_relocations >= 5) {
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- as(subset_data, "Spatial")
# Calculate kernel UD
kde <- kernelUD(subset_sp, h = 200)
kde_list[[name]] <- kde
} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
# Get the vertices
# Function to extract vertices for each "code" name stored in kde_list
get_vertices <- function(kde) {
# Extract vertices accounting for a certain percentage of the kernel density in an area unit
code_name <- tryCatch({
getverticeshr(kde, percent = 90, unout = "km2")
}, error = function(e) {
return(NULL)  # Return NULL if calculation fails
})
return(code_name)
}
# Create a list to store vertices for each "code" name stored in kde_list
vertices_list <- list()
# Iterate over each KDE object and extract vertices for each "code" name
for (i in 1:length(kde_list)) {
vertices <- get_vertices(kde_list[[i]])
if (!is.null(vertices)) {
# Add code name column to vertices data frame
vertices$Code <- unique_names[i]
vertices_list[[i]] <- vertices
}
}
# First of all, filter out NULL elements from vertices_list
vertices_list_filtered <- vertices_list[!sapply(vertices_list, is.null)]
# Check if the filtered list is not empty
if (length(vertices_list_filtered) == 0) {
stop("Error: vertices_list does not contain valid elements.")
} else {
# Second, create SpatialPolygons (all combined together)
home <- do.call(rbind, vertices_list_filtered)
}
# Assign the projection to the calculated homerange
proj4string(home) <- crs
home
mapview(home)
# Homerange as data frame
home1 <- as.data.frame(home)
home2 <- home1[, c("Code", "area")]
home3 <- tidyr::separate(home2, Code, into = c("Month", "Year", "Id"), sep = " ")
home3
# Convert back to SpatialPolygonsDataFrame
home3_sp <- SpatialPolygonsDataFrame(home, home3)
home3_sp
coordinates <- df_move[, c("x", "y")]
df_move <- st_as_sf(no_na_data_unique, coords = c("x", "y"), crs=32735)
df_move
# Prepare the layer to be used
df_move$x <- no_na_data_unique$x
df_move$y <- no_na_data_unique$y
df_move_df$time <- no_na_data_unique$time
df_move_df <- df_move
df_move_df$time <- no_na_data_unique$time
df_move_df$Code <- no_na_data_unique$Code
# Sort df_move_df by timestamp
df_move_sorted <- df_move_df[order(df_move$time), ]
df_move_sorted
df_move_df$time
# Sort df_move_df by timestamp
df_move_sorted <- df_move_df[order(df_move$time), ]
# Sort df_move_df by timestamp
df_move_sorted <- df_move_df[order(df_move_df$time), ]
df_move_sorted
# Check for unique values in the 'Code' column
unique_codes <- unique(df_move_sorted$Code)
# Check if there are any missing or empty values in 'Code'column
missing_codes <- is.na(unique_codes) | unique_codes == ""
if (any(missing_codes)) {
stop("Some code names are missing or empty.")
}
# Calculate traveled distance for each "Code" name
traveled_distances <- lapply(split(coordinates_sf, df_move_sorted$Code), function(group_coords) {
if (nrow(group_coords) > 1) {
# Calculate distance between consecutive points
distances <- st_distance(group_coords)
# Sum the distances in km
total_distance <- sum(distances)/1000
return(total_distance)
} else {
return(0)  # Return 0 if there's only one or zero points
}
})
# Check if there are any missing or empty values in 'Code'column
missing_codes <- is.na(unique_codes) | unique_codes == ""
if (any(missing_codes)) {
stop("Some code names are missing or empty.")
}
# Calculate traveled distance for each "Code" name
traveled_distances <- lapply(split(df_move_df, df_move_sorted$Code), function(group_coords) {
if (nrow(group_coords) > 1) {
# Calculate distance between consecutive points
distances <- st_distance(group_coords)
# Sum the distances in km
total_distance <- sum(distances)/1000
return(total_distance)
} else {
return(0)  # Return 0 if there's only one or zero points
}
})
# Convert the list of distances into a data frame
traveled_distances_df <- do.call(rbind, lapply(names(traveled_distances), function(code_dista) {
data.frame(Code = code_dista, Distance_km = traveled_distances[[code_dista]], row.names = NULL)
}))
# Remove the "[m]" suffix from the "Distance_km" column
traveled_distances_df$Distance_km <- gsub("\\s*\\[m\\]", "", traveled_distances_df$Distance_km)
merged_distance_homerange <- merge(traveled_distances_df, home2, by="Code")
# Splitting the Code column into three separate columns
merged_distance_homerange_split <- tidyr::separate(merged_distance_homerange, Code, into = c("Month", "Year", "Id"), sep = " ")
# Change the name of area
names(merged_distance_homerange_split) <- c("Month", "Year", "Id", "Distance_km", "Area_km2")
# Final file ready for correlation analysis
final_file <- merged_distance_homerange_split
final_file
traveled_distances
final_file
homeshape <- SpatialPolygonsDataFrame(home, home3)
mapview(homeshape)
corplot <- qplot(x = Distance_km, y = Area_km2, col= Id, data = final_file) +
geom_smooth(method = "lm") + xlab("Distance [km]") +
ylab("Area [km2]") + xlim(min(final_file$Distance_km), max(final_file$Distance_km)) +
ylim(min(final_file$Area_km2), max(final_file$Area_km2)) + guides(col = guide_legend(title = NULL))
corplot
final_file
corplot <- qplot(x = Distance_km, y = Area_km2, col= Id, data = final_file) +
geom_smooth(method = "lm") + xlab("Distance [km]") +
ylab("Area [km2]") + xlim(min(final_file$Distance_km), max(final_file$Distance_km)) +
ylim(min(final_file$Area_km2), max(final_file$Area_km2)) + guides(col = guide_legend(title = NULL))
qplot(x = Distance_km, y = Area_km2, col= Id, data = final_file) +
geom_smooth(method = "lm") + xlab("Distance [km]") +
ylab("Area [km2]") + xlim(min(final_file$Distance_km), max(final_file$Distance_km)) +
ylim(min(final_file$Area_km2), max(final_file$Area_km2)) + guides(col = guide_legend(title = NULL))
# Change the columns of area and distance as numeric
final_file$Distance_km <- as.numeric(final_file$Distance_km)
final_file$Area_km2 <- as.numeric(final_file$Area_km2)
qplot(x = Distance_km, y = Area_km2, col= Id, data = final_file) +
geom_smooth(method = "lm") + xlab("Distance [km]") +
ylab("Area [km2]") + xlim(min(final_file$Distance_km), max(final_file$Distance_km)) +
ylim(min(final_file$Area_km2), max(final_file$Area_km2)) + guides(col = guide_legend(title = NULL))
qplot(x = Distance_km, y = Area_km2, data = final_file) +
geom_smooth(method = "lm") + xlab("Distance [km]") +
ylab("Area [km2]") + xlim(min(final_file$Distance_km), max(final_file$Distance_km)) +
ylim(min(final_file$Area_km2), max(final_file$Area_km2)) + guides(col = guide_legend(title = NULL))
# Merge the computed distances with the spatial data based on the 'Code' column
distamove <- merge(df_move_sorted, traveled_distances_df, by = "Code")
# Initialize an empty list to store paths and associated code name
lines_list <- list()
codes <- character(0)
# Loop through each code name
for (code in unique(distamove$Code)) {
group_df <- distamove[distamove$Code == code, ]
if (nrow(group_df) > 1) {
line <- st_cast(st_union(st_cast(group_df, "MULTIPOINT")), "LINESTRING")
lines_list[[code]] <- line
codes <- c(codes, code)  # Add code to codes vector
} else {
lines_list[[code]] <- NA  # Indicate missing lines
}
}
# Filter out NA values from codes and lines_list
codes <- codes[!is.na(lines_list)]
lines_list <- lines_list[!is.na(lines_list)]
# Create a data frame with codes and corresponding lines
lines_df <- data.frame(Code = rep(codes, sapply(lines_list, length)),
geometry = do.call("c", lines_list),
row.names = NULL)
# Create a data frame with codes and corresponding lines
lines_df <- data.frame(Code = rep(codes, sapply(lines_list, length)),
geometry = do.call("c", lines_list),
row.names = NULL)
# Convert to sf object
movement <- st_as_sf(lines_df)
mapview(movement)
roxygen2::roxygenize()
roxygen2::roxygenize()
library(homdista)
devtools::document()
roxygen2::roxygenize()
library(homdista)
devtools::document()

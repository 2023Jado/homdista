} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Get unique names from df_move$Code
unique_names <- unique(df_move$Code)
# Loop through each unique "code name"
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Calculate KDE only if there are at least 5 relocations
if (num_relocations >= 5) {
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- as(subset_data, "Spatial")
# Calculate kernel UD
kde <- kernelUD(subset_sp, h = parh)
kde_list[[name]] <- kde
} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
file <- read.csv("C:/Users/Jado/Documents/DFGF/RE_HR_analysis_2020-2022/Combined file RDB & KRC/test_test.csv")
a <- homdista::homdista(file ,"%m/%d/%y %I:%M %p", 32735, "GORILLA_GROUP", 90, 200)
b <- homdista::hodicor(a, "spearman")
d <- homdista::distwalk(file, "%m/%d/%y %I:%M %p", 32735, "GORILLA_GROUP")
mapview(d)
e <- homdista::homekde(file, "%m/%d/%y %I:%M %p", 32735, "GORILLA_GROUP", 90, 200)
mapview(e)
tf <- "%m/%d/%y %I:%M %p"
crs_epsg <- 32735
Id_name <- "GORILLA_GROUP"
perc <- 90
parh <- 200
data_df <- file
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = tf, tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
# Sort the dataset based on the timestamp column
no_na_df_sorted <- data_df_no_na[order(data_df_no_na$time), ]
# Create a "code name" column to be used for home range estimation
no_na_df_sorted$Month_code <- month(no_na_df_sorted$time)
no_na_df_sorted$Year_code <- year(no_na_df_sorted$time)
no_na_df_sorted$Code <- paste(no_na_df_sorted$Month_code, no_na_df_sorted$Year_code, no_na_df_sorted$groupid)
# Change the data frame to "sf" object
df_move <- st_as_sf(no_na_df_sorted, coords = c("x", "y"), crs=crs_epsg)
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Get unique names from "df_move$Code"
unique_names <- unique(df_move$Code)
# Loop through each unique "code name"
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Calculate KDE only if there are at least 5 relocations
if (num_relocations >= 5) {
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- as(subset_data, "Spatial")
# Calculate kernel UD
kde <- kernelUD(subset_sp, h = parh)
kde_list[[name]] <- kde
} else {
cat("Skipping kde calculation for", name, "due to fewer than 5 relocations.\n")
}
}
# Get the vertices
# Function to extract vertices for each "code" name stored in kde_list
get_vertices <- function(kde) {
# Extract vertices accounting for a certain percentage of the kernel density in an area unit
code_name <- tryCatch({
getverticeshr(kde, percent = perc, unout = "km2")
}, error = function(e) {
return(NULL)  # Return NULL if calculation fails
})
return(code_name)
}
# Create a list to store vertices for each "code" name stored in kde_list
vertices_list <- list()
# Iterate over each KDE object and extract vertices for each "code" name
for (i in 1:length(kde_list)) {
vertices <- get_vertices(kde_list[[i]])
if (!is.null(vertices)) {
# Add code name column to vertices data frame
vertices$Code <- unique_names[i]
vertices_list[[i]] <- vertices
}
}
# First of all, filter out NULL elements from vertices_list
vertices_list_filtered <- vertices_list[!sapply(vertices_list, is.null)]
# Check if the filtered list is not empty
if (length(vertices_list_filtered) == 0) {
stop("Error: vertices_list does not contain valid elements.")
} else {
# Second, create SpatialPolygons (all combined together)
home <- do.call(rbind, vertices_list_filtered)
}
# Homerange as data frame
home1 <- as.data.frame(home)
home2 <- home1[, c("Code", "area")]
home3 <- tidyr::separate(home2, Code, into = c("Month", "Year", "Id"), sep = " ")
homeshape <- SpatialPolygonsDataFrame(home, home3)
homeranges <- lapply(unique(home$Code), function(code_home) {
mapview(home[home$Code == code_home, ],
col.regions = "transparent",
col = rainbow(length(unique(home$Code))),
layer.name = code_home,
alpha.regions = 0,
legend.opacity = 1,
alpha = 1,
lwd = 2
)
})
homeshape
class(homeshape)
# Convert "sp" object to "sf"
homerange_sf <- st_as_sf(homerange)
# Convert "sp" object to "sf"
homerange_sf <- st_as_sf(homeshape)
homerange_sf
# Define a palette for colors
palette <- rainbow(length(unique(homerange_sf$Id)))
# Create map with mapview
map <- mapview(homerange_sf, zcol = "Id", col.regions = palette, legend = TRUE, legend.title = "", legend.values = unique(homerange_sf$Id))
# Display the map
map
library(homdista)
library(homdista)
library(homdista)
file <- read.csv("C:/Users/Jado/Documents/DFGF/RE_HR_analysis_2020-2022/Combined file RDB & KRC/test_test.csv")
tf <- "%m/%d/%y %I:%M %p"
crs_epsg <- 32735
perc <- 90
parh <- 200
data_df <- file
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
Id_name <- "GORLLA_GROUP"
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = tf, tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
# Sort the dataset based on the timestamp column
no_na_df_sorted <- data_df_no_na[order(data_df_no_na$time), ]
# Create a "code name" column to be used for home range estimation
no_na_df_sorted$Month_code <- month(no_na_df_sorted$time)
no_na_df_sorted$Year_code <- year(no_na_df_sorted$time)
library(sp)
library(sf)
library(ade4)
library(adehabitatMA)
library(CircStats)
library(adehabitatLT)
library(adehabitatHR)
library(lubridate)
library(ggplot2)
library(scales)
library(mapview)
library(circular)
library(basemaps)
library(tidyr)
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = tf, tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
# Sort the dataset based on the timestamp column
no_na_df_sorted <- data_df_no_na[order(data_df_no_na$time), ]
# Create a "code name" column to be used for home range estimation
no_na_df_sorted$Month_code <- month(no_na_df_sorted$time)
no_na_df_sorted$Year_code <- year(no_na_df_sorted$time)
no_na_df_sorted$Code <- paste(no_na_df_sorted$Month_code, no_na_df_sorted$Year_code, no_na_df_sorted$groupid)
# Change the data frame to "sf" object
df_move <- st_as_sf(no_na_df_sorted, coords = c("x", "y"), crs=crs_epsg)
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Get unique names from df_move$Code
unique_names <- unique(df_move$Code)
# Loop through each unique "code name"
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Remove subset of data if there are fewer than 5 relocations
if (num_relocations < 5) {
df_move <- df_move[df_move$Code != name, ]
cat("Removed subset of data for", name, "due to fewer than 5 relocations.\n")
}
}
# Now perform KDE calculation for remaining data
for (name in unique(df_move$Code)) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- as(subset_data, "Spatial")
# Calculate kernel UD
kde <- kernelUD(subset_sp, h = parh)
kde_list[[name]] <- kde
}
# Get the vertices
# Function to extract vertices for each "code" name stored in kde_list
get_vertices <- function(kde) {
# Extract vertices accounting for a certain percentage of the kernel density in an area unit
code_name <- tryCatch({
getverticeshr(kde, percent = perc, unout = "km2")
}, error = function(e) {
return(NULL)  # Return NULL if calculation fails
})
return(code_name)
}
# Create a list to store vertices for each "code" name stored in kde_list
vertices_list <- list()
# Iterate over each KDE object and extract vertices for each "code" name
for (i in 1:length(kde_list)) {
vertices <- get_vertices(kde_list[[i]])
if (!is.null(vertices)) {
# Add code name column to vertices data frame
vertices$Code <- unique_names[i]
vertices_list[[i]] <- vertices
}
}
# First of all, filter out NULL elements from vertices_list
vertices_list_filtered <- vertices_list[!sapply(vertices_list, is.null)]
# Check if the filtered list is not empty
if (length(vertices_list_filtered) == 0) {
stop("Error: vertices_list does not contain valid elements.")
} else {
# Second, create SpatialPolygons (all combined together)
home <- do.call(rbind, vertices_list_filtered)
}
# Homerange as data frame
home1 <- as.data.frame(home)
home1
Id_name <- "GORILLA_GROUP"
data_df <- file
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = tf, tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
# Sort the dataset based on the timestamp column
no_na_df_sorted <- data_df_no_na[order(data_df_no_na$time), ]
# Create a "code name" column to be used for home range estimation
no_na_df_sorted$Month_code <- month(no_na_df_sorted$time)
no_na_df_sorted$Year_code <- year(no_na_df_sorted$time)
no_na_df_sorted$Code <- paste(no_na_df_sorted$Month_code, no_na_df_sorted$Year_code, no_na_df_sorted$groupid)
# Change the data frame to "sf" object
df_move <- st_as_sf(no_na_df_sorted, coords = c("x", "y"), crs=crs_epsg)
# Initialize a list to store KDE results for each unique name
kde_list <- list()
# Get unique names from df_move$Code
unique_names <- unique(df_move$Code)
# Loop through each unique "code name"
for (name in unique_names) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Remove subset of data if there are fewer than 5 relocations
if (num_relocations < 5) {
df_move <- df_move[df_move$Code != name, ]
cat("Removed subset of data for", name, "due to fewer than 5 relocations.\n")
}
}
# Now perform KDE calculation for remaining data
for (name in unique(df_move$Code)) {
# Subset the data for the current name
subset_data <- df_move[df_move$Code == name, ]
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- as(subset_data, "Spatial")
# Calculate kernel UD
kde <- kernelUD(subset_sp, h = parh)
kde_list[[name]] <- kde
}
# Get the vertices
# Function to extract vertices for each "code" name stored in kde_list
get_vertices <- function(kde) {
# Extract vertices accounting for a certain percentage of the kernel density in an area unit
code_name <- tryCatch({
getverticeshr(kde, percent = perc, unout = "km2")
}, error = function(e) {
return(NULL)  # Return NULL if calculation fails
})
return(code_name)
}
# Create a list to store vertices for each "code" name stored in kde_list
vertices_list <- list()
# Iterate over each KDE object and extract vertices for each "code" name
for (i in 1:length(kde_list)) {
vertices <- get_vertices(kde_list[[i]])
if (!is.null(vertices)) {
# Add code name column to vertices data frame
vertices$Code <- unique_names[i]
vertices_list[[i]] <- vertices
}
}
# First of all, filter out NULL elements from vertices_list
vertices_list_filtered <- vertices_list[!sapply(vertices_list, is.null)]
# Check if the filtered list is not empty
if (length(vertices_list_filtered) == 0) {
stop("Error: vertices_list does not contain valid elements.")
} else {
# Second, create SpatialPolygons (all combined together)
home <- do.call(rbind, vertices_list_filtered)
}
# Homerange as data frame
home1 <- as.data.frame(home)
home2 <- home1[, c("Code", "area")]
home3 <- tidyr::separate(home2, Code, into = c("Month", "Year", "Id"), sep = " ")
home3
# Convert back to SpatialPolygonsDataFrame
home3_sp <- SpatialPolygonsDataFrame(home, home3)
home3_sp
# Prepare the layer to be used
df_move$x <- no_na_df_sorted$x
dev.off()
# Prepare the layer to be used
df_move$x <- no_na_df_sorted$x
df_move
# Sort df_move by timestamp
df_move_sorted <- df_move[order(df_move$time), ]
# Check for unique values in the 'Code' column
unique_codes <- unique(df_move_sorted$Code)
# Check if there are any missing or empty values in 'Code'column
missing_codes <- is.na(unique_codes) | unique_codes == ""
if (any(missing_codes)) {
stop("Some code names are missing or empty.")
}
# Initialize an empty list to store distances
traveled_distances <- list()
# Loop through each "Code" name
for (code in unique_codes) {
# Subset the data for the current code
subset_data <- df_move_sorted[df_move_sorted$Code == code, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Proceed if there are at least 5 relocations
if (num_relocations >= 5) {
# Calculate distance between consecutive points
distances <- st_distance(subset_data)
# Sum the distances in km
total_distance <- sum(distances) / 1000
# Store the distance for this code
traveled_distances[[code]] <- total_distance
} else {
cat("Deleting subset for", code, "due to fewer than 5 relocations.\n")
# Delete this subset from the dataset
df_move_sorted <- df_move_sorted[df_move_sorted$Code != code, ]
}
}
# Convert the list of distances into a data frame
traveled_distances_df <- data.frame(
Code = names(traveled_distances),
Distance_km = unlist(traveled_distances),
row.names = NULL
)
# Remove the "[m]" suffix from the "Distance_km" column
traveled_distances_df$Distance_km <- gsub("\\s*\\[m\\]", "", traveled_distances_df$Distance_km)
merged_distance_homerange <- merge(traveled_distances_df, home2, by="Code")
# Splitting the Code column into three separate columns
merged_distance_homerange_split <- tidyr::separate(merged_distance_homerange, Code, into = c("Month", "Year", "Id"), sep = " ")
# Change the name of area
names(merged_distance_homerange_split) <- c("Month", "Year", "Id", "Distance_km", "Area_km2")
# Final file ready for correlation analysis
final_file <- merged_distance_homerange_split
final_file
traveled_distances_df$Distance_km
home2
library(homdista)
library(homdista)
roxygen2::roxygenize()
devtools::document()
library(homdista)
library(homdista)
library(homdista)
file <- read.csv("C:/Users/Jado/Documents/DFGF/RE_HR_analysis_2020-2022/Combined file RDB & KRC/test_test.csv")
file <- read.csv("C:/Users/Jado/Documents/DFGF/RE_HR_analysis_2020-2022/Combined file RDB & KRC/test_test.csv")
tf <- "%m/%d/%y %I:%M %p"
crs_epsg <- 32735
Id_name <-  "GORILLA_GROUP"
perc <- 90
parh <- 200
data_df <- file
# Rename the column
names(data_df)[which(names(data_df) == Id_name)] <- "groupid"
# Change the time format
data_df$time <- as.POSIXct(data_df$timestamp, format = tf, tz="UTC")
# Remove the NA from data_df
data_df_no_na <- na.omit(data_df)
# Sort the dataset based on the timestamp column
no_na_df_sorted <- data_df_no_na[order(data_df_no_na$time), ]
# Create a "code name" column to be used for home range estimation
no_na_df_sorted$Month_code <- month(no_na_df_sorted$time)
no_na_df_sorted$Year_code <- year(no_na_df_sorted$time)
no_na_df_sorted$Code <- paste(no_na_df_sorted$Month_code, no_na_df_sorted$Year_code, no_na_df_sorted$groupid)
# Change the data frame to "sf" object
df_move <- st_as_sf(no_na_df_sorted, coords = c("x", "y"), crs=crs_epsg)
# Get unique names from df_move$Code
unique_names <- unique(df_move$Code)
# Initialize an empty list to store KDE results
kde_list <- list()
# Loop through each unique "code name"
for (name in unique(df_move$Code)) {
# Subset the data for the current code name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Proceed if there are at least 5 relocations
if (num_relocations >= 5) {
# Calculate kernel UD
kde <- kernelUD(as(subset_data, "SpatialPoints"), h = parh)
kde_list[[name]] <- kde
} else {
cat("Deleting KDE result for", name, "due to fewer than 5 relocations.\n")
# Delete this subset from the list
kde_list[[name]] <- NULL
}
}
# Get unique names from df_move$Code
unique_names <- unique(df_move$Code)
# Initialize an empty list to store KDE results
kde_list <- list()
# Loop through each unique "code name"
for (name in unique(df_move$Code)) {
# Subset the data for the current code name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Proceed if there are at least 5 relocations
if (num_relocations >= 5) {
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- st_as_sf(subset_data, coords = c("x", "y"))
# Calculate kernel UD
kde <- kernelUD(subset_sp, h = parh)
kde_list[[name]] <- kde
} else {
cat("Deleting KDE result for", name, "due to fewer than 5 relocations.\n")
# Delete this subset from the list
kde_list[[name]] <- NULL
}
}
# Initialize an empty list to store KDE results
kde_list <- list()
# Loop through each unique "code name"
for (name in unique(df_move$Code)) {
# Subset the data for the current code name
subset_data <- df_move[df_move$Code == name, ]
# Check the number of relocations
num_relocations <- nrow(subset_data)
# Proceed if there are at least 5 relocations
if (num_relocations >= 5) {
# Convert subset_data to SpatialPointsDataFrame
subset_sp <- st_as_sf(subset_data, coords = c("x", "y"))
# Convert subset_sp to SpatialPoints object
subset_sp_points <- as(subset_sp, "Spatial")
# Calculate kernel UD
kde <- kernelUD(subset_sp_points, h = parh)
kde_list[[name]] <- kde
} else {
cat("Deleting KDE result for", name, "due to fewer than 5 relocations.\n")
# Delete this subset from the list
kde_list[[name]] <- NULL
}
}
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
library(homdista)
roxygen2::roxygenize()
devtools::document()
library(homdista)
devtools::document()
roxygen2::roxygenize()
devtools::document()
library(homdista)
roxygen2::roxygenize()
devtools::document()
devtools::install_git("https://github.com/2023Jado/homdista")
library(homdista)
roxygen2::roxygenize()
library(homdista)
roxygen2::roxygenize()
devtools::document()
library(homdista)
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
library(homdista)
roxygen2::roxygenize()
devtools::document()
roxygen2::roxygenize()
devtools::document()
library(homdista)
